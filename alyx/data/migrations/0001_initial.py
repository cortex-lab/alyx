# Generated by Django 2.1.1 on 2018-10-15 09:14

import django.contrib.postgres.fields.jsonb
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='DataFormat',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(help_text="short identifying name, e.g. 'npy'", max_length=255, unique=True)),
                ('description', models.CharField(blank=True, help_text="Human-readable description of the file format e.g. 'npy-formatted square numerical array'.", max_length=255)),
                ('file_extension', models.CharField(help_text='file extension, starting with a dot.', max_length=255, validators=[django.core.validators.RegexValidator('^\\.[^\\.]+$', code='invalid_file_extension', message='Invalid file extension, should start with a dot')])),
                ('matlab_loader_function', models.CharField(blank=True, help_text="Name of MATLAB loader function'.", max_length=255)),
                ('python_loader_function', models.CharField(blank=True, help_text="Name of Python loader function'.", max_length=255)),
            ],
            options={
                'verbose_name_plural': 'data formats',
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='DataRepository',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(max_length=255, unique=True)),
                ('hostname', models.CharField(blank=True, help_text='Host name of the network drive', max_length=200, validators=[django.core.validators.RegexValidator('^[a-zA-Z0-9\\.\\-\\_]+$', code='invalid_hostname', message='Invalid hostname')])),
                ('data_url', models.URLField(blank=True, help_text='URL of the data repository, if it is accessible via HTTP', null=True)),
                ('timezone', models.CharField(blank=True, default='GB', help_text='Timezone of the server (see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)', max_length=64)),
                ('globus_path', models.CharField(blank=True, help_text='absolute path to the repository on the server e.g. /mnt/something/', max_length=1000)),
                ('globus_endpoint_id', models.UUIDField(blank=True, help_text='UUID of the globus endpoint', null=True)),
                ('globus_is_personal', models.NullBooleanField(help_text='whether the Globus endpoint is personal or not. By default, Globus cannot transfer a file between two personal endpoints.')),
            ],
            options={
                'verbose_name_plural': 'data repositories',
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='DataRepositoryType',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(max_length=255, unique=True)),
            ],
            options={
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='Dataset',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(help_text='Long name', max_length=255)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('created_datetime', models.DateTimeField(blank=True, default=django.utils.timezone.now, help_text='The creation datetime.', null=True)),
                ('generating_software', models.CharField(blank=True, help_text="e.g. 'ChoiceWorld 0.8.3'", max_length=255)),
                ('file_size', models.IntegerField(blank=True, help_text='Size in bytes', null=True)),
                ('md5', models.UUIDField(blank=True, help_text='MD5 hash of the data buffer', null=True)),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='DatasetType',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(blank=True, help_text="Short identifying nickname, e.g. 'spikes'", max_length=255, unique=True)),
                ('description', models.CharField(blank=True, help_text="Human-readable description of data type. Should say what is in the file, and how to read it. For DataCollections, it should list what Datasets are expected in the the collection. E.g. 'Files related to spike events, including spikes.times.npy, spikes.clusters.npy, spikes.amps.npy, spikes.depths.npy", max_length=1023)),
                ('filename_pattern', models.CharField(help_text="File name pattern (with wildcards) for this file in ALF naming convention. E.g. 'spikes.times.*' or '*.timestamps.*', or 'spikes.*.*' for a DataCollection, which would include all files starting with the word 'spikes'.", max_length=255, unique=True)),
            ],
            options={
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='FileRecord',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(blank=True, help_text='Long name', max_length=255)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('relative_path', models.CharField(help_text='path name within repository', max_length=1000, validators=[django.core.validators.RegexValidator('^[a-zA-Z0-9\\_][^\\\\\\:]+$', code='invalid_path', message='Invalid path')])),
                ('exists', models.BooleanField(default=False, help_text='Whether the file exists in the data repository')),
                ('data_repository', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='data.DataRepository')),
                ('dataset', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='file_records', to='data.Dataset')),
            ],
            options={
                'abstract': False,
            },
        ),
    ]
