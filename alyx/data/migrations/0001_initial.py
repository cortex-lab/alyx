# Generated by Django 2.0.6 on 2018-07-13 13:49

import django.contrib.postgres.fields.jsonb
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='DataFormat',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(help_text="short identifying nickname, e..g 'npy'.", max_length=255, unique=True)),
                ('description', models.CharField(blank=True, help_text="Human-readable description of the file format e.g. 'npy-formatted square numerical array'.", max_length=255)),
                ('file_extension', models.CharField(help_text='file extension, starting with a dot.', max_length=255, validators=[django.core.validators.RegexValidator('^\\.[^\\.]+$', code='invalid_file_extension', message='Invalid file extension, should start with a dot')])),
                ('matlab_loader_function', models.CharField(blank=True, help_text="Name of MATLAB loader function'.", max_length=255)),
                ('python_loader_function', models.CharField(blank=True, help_text="Name of Python loader function'.", max_length=255)),
            ],
            options={
                'verbose_name_plural': 'data formats',
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='DataRepository',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(max_length=255, unique=True)),
                ('dns', models.CharField(blank=True, help_text='DNS of the network drive', max_length=200, validators=[django.core.validators.RegexValidator('^[a-zA-Z0-9\\.\\-\\_]+$', code='invalid_dns', message='Invalid DNS')])),
                ('data_url', models.URLField(blank=True, help_text='URL of the data repository, if it is accessible via HTTP', null=True)),
                ('timezone', models.CharField(blank=True, default='GB', help_text='Timezone of the server (see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)', max_length=64)),
                ('globus_path', models.CharField(blank=True, help_text='absolute path to the repository on the server e.g. /mnt/something/', max_length=1000)),
                ('globus_endpoint_id', models.UUIDField(blank=True, help_text='UUID of the globus endpoint', null=True)),
                ('globus_is_personal', models.NullBooleanField(help_text='whether the Globus endpoint is personal or not. By default, Globus cannot transfer a file between two personal endpoints.')),
            ],
            options={
                'verbose_name_plural': 'data repositories',
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='DataRepositoryType',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(max_length=255, unique=True)),
            ],
            options={
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='Dataset',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('created_datetime', models.DateTimeField(blank=True, default=django.utils.timezone.now, help_text='The creation datetime.', null=True)),
                ('generating_software', models.CharField(blank=True, help_text="e.g. 'ChoiceWorld 0.8.3'", max_length=255)),
                ('name', models.CharField(max_length=255)),
                ('file_size', models.IntegerField(blank=True, help_text='Size in bytes', null=True)),
                ('md5', models.UUIDField(blank=True, help_text='MD5 hash of the data buffer', null=True)),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='DatasetType',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(blank=True, help_text="Short identifying nickname, e.g. 'spikes'", max_length=255, unique=True)),
                ('description', models.CharField(blank=True, help_text="Human-readable description of data type. Should say what is in the file, and how to read it. For DataCollections, it should list what Datasets are expected in the the collection. E.g. 'Files related to spike events, including spikes.times.npy, spikes.clusters.npy, spikes.amps.npy, spikes.depths.npy", max_length=1023)),
                ('filename_pattern', models.CharField(help_text="File name pattern (with wildcards) for this file in ALF naming convention. E.g. 'spikes.times.*' or '*.timestamps.*', or 'spikes.*.*' for a DataCollection, which would include all files starting with the word 'spikes'.", max_length=255, unique=True)),
            ],
            options={
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='FileRecord',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('relative_path', models.CharField(help_text='path name within repository', max_length=1000, validators=[django.core.validators.RegexValidator('^[a-zA-Z0-9\\_][^\\\\\\:]+$', code='invalid_path', message='Invalid path')])),
                ('exists', models.BooleanField(default=False, help_text='Whether the file exists in the data repository')),
                ('data_repository', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='data.DataRepository')),
                ('dataset', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='file_records', to='data.Dataset')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='Timescale',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('json', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='Structured data, formatted in a user-defined way', null=True)),
                ('name', models.CharField(blank=True, help_text='informal name describing this field', max_length=255)),
                ('nominal_start', models.DateTimeField(blank=True, help_text='Approximate date and time corresponding to 0 samples', null=True)),
                ('nominal_time_unit', models.FloatField(blank=True, help_text='Nominal time unit for this timescale (in seconds)', null=True)),
                ('final', models.BooleanField(help_text='set to true for the final results of time alignment, in seconds')),
                ('info', models.CharField(blank=True, help_text='any information, e.g. length of break around 300s inferred approximately from computer clock', max_length=255)),
            ],
            options={
                'verbose_name_plural': 'Time scales',
            },
        ),
    ]
